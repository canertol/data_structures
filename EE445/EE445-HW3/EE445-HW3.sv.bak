module basic_comp (
	clk,
	set_S, set_FGI, set_FGO,
	FGI_out, FGO_out,
	INPR_in, OUTR_out
);

	/* FILL HERE */

endmodule


/*
 * CPU modules
 */
module control_timing_unit (
	// Inputs
	clk, IR,
	IRQ, IEN, FGI, FGO, E, AC_MSB, AC_zero, DR_zero,

	// Outputs
	load_AR, clr_AR, inc_AR,
	load_PC, clr_PC, inc_PC,
	load_DR, inc_DR,
	load_AC, clr_AC, inc_AC,
	load_IR,
	load_TR,
	load_OUTR,
	set_IRQ, clr_IRQ,
	set_IEN, clr_IEN,
	load_E, clr_E, comp_E,
	clr_S,
	clr_FGI,
	clr_FGO,
	ALU_and, ALU_add, ALU_comp, ALU_cir, ALU_cil, ALU_trans_dr, ALU_trans_inpr,
	RAM_r, RAM_w,
	bus_select
);

	/* FILL HERE */

endmodule


module control_logic (
	// Inputs
	clk, D, T,
	IR, I, IRQ, IEN, FGI, FGO, E, AC_MSB, AC_zero, DR_zero,
	// Outputs
	load_AR, clr_AR, inc_AR,
	load_PC, clr_PC, inc_PC,
	load_DR, inc_DR,
	load_AC, clr_AC, inc_AC,
	load_IR,
	load_TR,
	load_OUTR,
	load_I,
	set_IRQ, clr_IRQ,
	set_IEN, clr_IEN,
	load_E, clr_E, comp_E,
	clr_S,
	clr_FGI,
	clr_FGO,
	clr_SC,
	ALU_and, ALU_add, ALU_comp, ALU_cir, ALU_cil, ALU_trans_dr, ALU_trans_inpr,
	RAM_r, RAM_w,
	bus_select
);

	/* FILL HERE */

endmodule


module alu (
	// Inputs
	from_DR, from_INPR, from_AC, from_E,
	// Outputs
	out, carry,
	// Signals
	and_, add, comp, cir, cil, trans_dr, trans_inpr
);

	/* FILL HERE */

endmodule


/*
 * Basic modules
 */
 module register #(parameter WIDTH = 8) (
	clk,
	in, out,
	load, clr, inc
);
 	input clk;
	input [WIDTH-1:0] in;
	output reg [WIDTH-1:0] out;
	input load, clr, inc;

	initial
	begin
		out = {WIDTH{1'b0}};
	end

	always @(posedge clk)
	begin
		if (load)
			out <= in;
		else if (clr)
			out <= {WIDTH{1'b0}};
		else if (inc)
			out <= out + {{WIDTH-1{1'b0}}, 1'b1};
	end
endmodule


module ff (
	clk,
	in, out,
	load, set, clr, comp
);
	input clk;
	input in;
	output reg out;
	input load, set, clr, comp;

	initial
	begin
		out = 1'b0;
	end

	always @(posedge clk)
	begin
		if (load)
			out <= in;
		else if (set)
			out <= 1'b1;
		else if (clr)
			out <= 1'b0;
		else if (comp)
			out <= ~out;
	end
endmodule


module counter #(parameter WIDTH = 4) (
	clk,
	out,
	clr,
);
	input clk;
	output reg [WIDTH-1:0] out;
	input clr;

	initial
	begin
		out = {WIDTH{1'b0}};
	end

	always @(posedge clk)
	begin
		if (clr)
			out <= {WIDTH{1'b0}};
		else
			out <= out + {{WIDTH-1{1'b0}}, 1'b1};
	end
endmodule


module decoder #(parameter IN_WIDTH = 3) (
	in, out
);
	input [IN_WIDTH-1:0] in;
	output reg [(1<<IN_WIDTH)-1:0] out;

	always @(in)
	begin
		out = {(1<<IN_WIDTH){1'b0}};
		out[in] = 1'b1;
	end

endmodule


module encoder #(parameter OUT_WIDTH = 3) (
	in,	out
);
	input [(1<<OUT_WIDTH)-1:0] in;
	output reg [OUT_WIDTH-1:0] out;

	integer i;
	always @(in)
	begin
		out = {OUT_WIDTH{1'b0}};
		for (i=(1<<OUT_WIDTH)-1; i>=0; i=i-1)
			if (in[i]) out = i;
	end
endmodule


module bus #(parameter DATA_WIDTH = 16, SELECT_WIDTH = 3) (
	select,
	in, out
);
	input [SELECT_WIDTH-1:0] select;
	input [DATA_WIDTH-1:0] in [0:(1<<SELECT_WIDTH)-1];
	output reg [DATA_WIDTH-1:0] out;

	always @(*)
	begin
		out = in[select];
	end
endmodule


module ram #(parameter ADDR_WIDTH = 12, DATA_WIDTH = 16) (
	clk,
	addr,
	r, w,
	in, out
);
	input clk;
	input [ADDR_WIDTH-1:0] addr;
	input r;
	input w;
	input [DATA_WIDTH-1:0] in;
	output [DATA_WIDTH-1:0] out;

	reg [DATA_WIDTH-1:0] memory [0:(1<<ADDR_WIDTH)-1];

	assign out = r ? memory[addr] : {DATA_WIDTH{1'bz}};

	always @(posedge clk)
		if (w)
			memory[addr] <= in;

endmodule
