|CONTROLLER
clk => clk.IN1
reset => reset.IN1
Inst[0] => ~NO_FANOUT~
Inst[1] => ~NO_FANOUT~
Inst[2] => ~NO_FANOUT~
Inst[3] => ~NO_FANOUT~
Inst[4] => ~NO_FANOUT~
Inst[5] => ~NO_FANOUT~
Inst[6] => ~NO_FANOUT~
Inst[7] => ~NO_FANOUT~
Inst[8] => ~NO_FANOUT~
Inst[9] => ~NO_FANOUT~
Inst[10] => ~NO_FANOUT~
Inst[11] => ~NO_FANOUT~
Inst[12] => Inst[12].IN1
Inst[13] => Inst[13].IN1
Inst[14] => Inst[14].IN1
Inst[15] => Inst[15].IN1
Inst[16] => ~NO_FANOUT~
Inst[17] => ~NO_FANOUT~
Inst[18] => ~NO_FANOUT~
Inst[19] => ~NO_FANOUT~
Inst[20] => Inst[20].IN1
Inst[21] => Inst[21].IN1
Inst[22] => Inst[22].IN1
Inst[23] => Inst[23].IN1
Inst[24] => Inst[24].IN1
Inst[25] => Inst[25].IN1
Inst[26] => Inst[26].IN1
Inst[27] => Inst[27].IN1
Inst[28] => Inst[28].IN1
Inst[29] => Inst[29].IN1
Inst[30] => Inst[30].IN1
Inst[31] => Inst[31].IN1
ALUFlags[0] => ALUFlags[0].IN1
ALUFlags[1] => ALUFlags[1].IN1
ALUFlags[2] => ALUFlags[2].IN1
ALUFlags[3] => ALUFlags[3].IN1
RegSrc[0] << DEC:decoder.port4
RegSrc[1] << DEC:decoder.port4
RegWrite << COND_LOGIC:conditional_logic.port9
ImmSrc[0] << DEC:decoder.port3
ImmSrc[1] << DEC:decoder.port3
ALUSrc << DEC:decoder.port8
ALUControl[0] << DEC:decoder.port12
ALUControl[1] << DEC:decoder.port12
MemWrite << COND_LOGIC:conditional_logic.port10
MemtoReg << DEC:decoder.port7
PCSrc << COND_LOGIC:conditional_logic.port11
Shift << DEC:decoder.port6


|CONTROLLER|DEC:decoder
Op[0] => controls.OUTPUTSELECT
Op[0] => Mux0.IN4
Op[0] => Mux1.IN4
Op[0] => controls.OUTPUTSELECT
Op[0] => Mux2.IN5
Op[0] => ImmSrc[0].DATAIN
Op[0] => MemtoReg.DATAIN
Op[1] => Mux0.IN3
Op[1] => Mux1.IN3
Op[1] => Mux2.IN4
Op[1] => RegSrc[0].DATAIN
Op[1] => ImmSrc[1].DATAIN
Op[1] => PCS.IN1
Funct[0] => FlagW.IN1
Funct[0] => FlagW.DATAB
Funct[0] => Mux1.IN5
Funct[0] => controls.DATAB
Funct[0] => controls.DATAB
Funct[1] => Decoder0.IN3
Funct[2] => Decoder0.IN2
Funct[2] => Mux3.IN10
Funct[2] => Decoder1.IN1
Funct[3] => Decoder0.IN1
Funct[3] => Mux3.IN9
Funct[4] => Decoder0.IN0
Funct[4] => Mux3.IN8
Funct[4] => Decoder1.IN0
Funct[5] => Mux0.IN5
Rd[0] => Equal2.IN3
Rd[1] => Equal2.IN2
Rd[2] => Equal2.IN1
Rd[3] => Equal2.IN0
ImmSrc[0] <= Op[0].DB_MAX_OUTPUT_PORT_TYPE
ImmSrc[1] <= Op[1].DB_MAX_OUTPUT_PORT_TYPE
RegSrc[0] <= Op[1].DB_MAX_OUTPUT_PORT_TYPE
RegSrc[1] <= controls.DB_MAX_OUTPUT_PORT_TYPE
NoWrite <= NoWrite$latch.DB_MAX_OUTPUT_PORT_TYPE
Shift <= Shift$latch.DB_MAX_OUTPUT_PORT_TYPE
MemtoReg <= Op[0].DB_MAX_OUTPUT_PORT_TYPE
ALUSrc <= Mux0.DB_MAX_OUTPUT_PORT_TYPE
RegW <= Mux1.DB_MAX_OUTPUT_PORT_TYPE
MemW <= controls.DB_MAX_OUTPUT_PORT_TYPE
PCS <= PCS.DB_MAX_OUTPUT_PORT_TYPE
ALUControl[0] <= ALUControl.DB_MAX_OUTPUT_PORT_TYPE
ALUControl[1] <= ALUControl.DB_MAX_OUTPUT_PORT_TYPE
FlagW[0] <= FlagW.DB_MAX_OUTPUT_PORT_TYPE
FlagW[1] <= FlagW.DB_MAX_OUTPUT_PORT_TYPE


|CONTROLLER|COND_LOGIC:conditional_logic
clk => ~NO_FANOUT~
reset => ~NO_FANOUT~
Cond[0] => ~NO_FANOUT~
Cond[1] => ~NO_FANOUT~
Cond[2] => ~NO_FANOUT~
Cond[3] => ~NO_FANOUT~
ALUFlags[0] => ~NO_FANOUT~
ALUFlags[1] => ~NO_FANOUT~
ALUFlags[2] => ~NO_FANOUT~
ALUFlags[3] => ~NO_FANOUT~
FlagW[0] => ~NO_FANOUT~
FlagW[1] => ~NO_FANOUT~
PCS => PCSrc.DATAIN
RegW => RegWrite.DATAB
MemW => MemWrite.DATAIN
NoWrite => RegWrite.OUTPUTSELECT
RegWrite <= RegWrite.DB_MAX_OUTPUT_PORT_TYPE
MemWrite <= MemW.DB_MAX_OUTPUT_PORT_TYPE
PCSrc <= PCS.DB_MAX_OUTPUT_PORT_TYPE


